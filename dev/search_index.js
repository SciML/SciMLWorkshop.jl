var documenterSearchIndex = {"docs":
[{"location":"solutions/dc_motor_control/#Controlling-a-DC-Motor-(E)","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"","category":"section"},{"location":"solutions/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"using ModelingToolkit, DifferentialEquations, Plots, ControlSystemsBase\nusing ModelingToolkitStandardLibrary, ModelingToolkitStandardLibrary.Electrical, ModelingToolkitStandardLibrary.Mechanical.Rotational, ModelingToolkitStandardLibrary.Blocks\n@variables t\n# R = 0.5 # [Ohm] armature resistance\n# L = 4.5e-3 # [H] armature inductance\n# k = 0.5 # [N.m/A] motor constant\n# J = 0.02 # [kg.m²] inertia\n# f = 0.01 # [N.m.s/rad] friction factor\nfunction Motor(; name, R = 0.5, L = 4.5e-3, k = 0.5, J = 0.02, f = 0.01)\n    @named ground = Ground()\n    @named source = Voltage()\n    @named R1 = Resistor(R = R)\n    @named L1 = Inductor(L = L)\n    @named emf = EMF(k = k)\n    @named fixed = Fixed()\n    @named load = Torque(use_support = false)\n    @named inertia = Inertia(J = J)\n    @named friction = Damper(d = f)\n\n    connections = [connect(fixed.flange, emf.support, friction.flange_b)\n                   connect(emf.flange, friction.flange_a, inertia.flange_a)\n                   connect(inertia.flange_b, load.flange)\n                   connect(source.p, R1.p)\n                   connect(R1.n, L1.p)\n                   connect(L1.n, emf.p)\n                   connect(emf.n, source.n, ground.g)]\n    subcomps = [\n        ground,\n        source,\n        R1,\n        L1,\n        emf,\n        fixed,\n        load,\n        inertia,\n        friction,\n    ]\n    @named model = ODESystem(connections, t)\n    compose(model, subcomps)\nend\n\npi_k = 1.1\npi_T = 0.05\n@named motor = Motor();\ntau_L_step = -0.3 # [N.m] amplitude of the load torque step\n@named ref = Blocks.Step(height = 1, start_time = 0)\n@named pi_controller = Blocks.LimPI(k = pi_k, T = pi_T, u_max = 10, Ta = 0.035)\n@named feedback = Blocks.Feedback()\n@named load_step = Blocks.Step(height = tau_L_step, start_time = 3)\n@named speed_sensor = SpeedSensor()\n\nconnections = [\n            connect(motor.load.flange, speed_sensor.flange)\n            connect(ref.output, feedback.input1)\n            connect(speed_sensor.w, :y, feedback.input2)\n            connect(load_step.output, motor.load.tau)\n            connect(feedback.output, pi_controller.err_input)\n            connect(pi_controller.ctr_output, :u, motor.source.V)]\n\nsubcomps = [\n    motor,\n    ref,\n    pi_controller,\n    feedback,\n    load_step,\n    speed_sensor,\n]\n@named model = ODESystem(connections, t)\nmodel = compose(model, subcomps)\n\nsys = structural_simplify(model)\nprob = ODEProblem(sys, [], (0, 6.0))\nsol = solve(prob, Rodas4())\n\np1 = plot(sol.t, sol[motor.inertia.w], ylabel = \"Angular Vel. in rad/s\",\n                label = \"Measurement\", title = \"DC Motor with Speed Controller\")\nPlots.plot!(sol.t, sol[ref.output.u], label = \"Reference\")\np2 = plot(sol.t, sol[motor.load.tau.u], ylabel = \"Disturbance in Nm\", label = \"\")\n\nmat, simplified_sys = get_sensitivity(model, :y);\nS = ss(mat...);\nbplot = bodeplot(S, plotphase=false)\nnplot = nyquistplot(-ss(get_looptransfer(model, :u)[1]...))\nplot(p1, p2, bplot, nplot, layout = (2, 2))","category":"page"},{"location":"exercises/gsa_henon_heiles/#Global-Parameter-Sensitivity-and-Optimality-with-GPU-and-Distributed-Ensembles-(B)","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"","category":"section"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"In this example we will investigate how the parameters \"generally\" effect the solution in the chaotic Henon-Heiles system. By \"generally\" we will use global sensitivity analysis methods to get an average global characterization of the parameters on the solution. In addition to a global sensitivity approach, we will generate large ensembles of solutions with different parameters using a GPU-based parallelism approach.","category":"page"},{"location":"exercises/gsa_henon_heiles/#Part-1:-Implementing-the-Henon-Heiles-System-(B)","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Part 1: Implementing the Henon-Heiles System (B)","text":"","category":"section"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"The Henon-Heiles Hamiltonian system is described by the ODEs:","category":"page"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"beginalign*\nfracdp_1dt = -q_1 (1 + 2q_2)\nfracdp_2dt = -q_2 - (q_1^2 - q_2^2)\nfracdq_1dt = p_1\nfracdq_2dt = p_2\nendalign*","category":"page"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"with initial conditions u_0 = 01000005. Solve this system over the timespan tin01000","category":"page"},{"location":"exercises/gsa_henon_heiles/#(Optional)-Part-2:-Alternative-Dynamical-Implmentations-of-Henon-Heiles-(B)","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"(Optional) Part 2: Alternative Dynamical Implmentations of Henon-Heiles (B)","text":"","category":"section"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"The Henon-Heiles defines a Hamiltonian system with certain structures which can be utilized for a more efficient solution. Use the Dynamical problems page to define a SecondOrderODEProblem corresponding to the acceleration terms:","category":"page"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"beginalign*\nfracd^2q_1dt^2 = -q_1 (1 + 2q_2)\nfracd^2q_2dt^2 = -q_2 - (q_1^2 - q_2^2)\nendalign*","category":"page"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"Solve this with a method that is specific to dynamical problems, like DPRKN6.","category":"page"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"The Hamiltonian can also be directly described:","category":"page"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"H(pq) = frac12(p_1^2 + p_2^2) + frac12(q_1^2+q_2^2+2q_1^2 q_2 - frac23q_2^3)","category":"page"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"Solve this problem using the HamiltonianProblem constructor from DiffEqPhysics.jl.","category":"page"},{"location":"exercises/gsa_henon_heiles/#Part-3:-Parallelized-Ensemble-Solving","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Part 3: Parallelized Ensemble Solving","text":"","category":"section"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"To understand the orbits of the Henon-Heiles system, it can be useful to solve the system with many different initial conditions. Use the ensemble interface to solve with randomized initial conditions in parallel using threads with EnsembleThreads(). Then, use addprocs() to add more cores and solve using EnsembleDistributed(). The former will solve using all of the cores on a single computer, while the latter will use all of the cores on which there are processors, which can include thousands across a supercomputer! See Julia's parallel computing setup page for more details on the setup.","category":"page"},{"location":"exercises/gsa_henon_heiles/#Part-4:-Parallelized-GPU-Ensemble-Solving","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Part 4: Parallelized GPU Ensemble Solving","text":"","category":"section"},{"location":"exercises/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"Setup the CUDAnative.jl library and use the EnsembleGPUArray() method to parallelize the solution across the thousands of cores of a GPU. Note that this will efficiency solve for hundreds of thousands of trajectores.","category":"page"},{"location":"exercises/stiffbio_uncertainty/#Investigating-Sources-of-Randomness-and-Uncertainty-in-a-Stiff-Biological-System-(B)","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"","category":"section"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"In this problem we will walk through the basics of simulating models with DifferentialEquations.jl. Let's take the Oregonator model of the Belousov-Zhabotinskii chemical reaction system. This system describes a classical example in non-equilibrium thermodynmics and is a well-known natural chemical oscillator.","category":"page"},{"location":"exercises/stiffbio_uncertainty/#Part-1:-Simulating-the-Oregonator-ODE-model","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Part 1: Simulating the Oregonator ODE model","text":"","category":"section"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"When modeling, usually one starts off by investigating the deterministic model. The deterministic ODE formulation of the Oregonator is given by the equations","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"beginalign*\nfracdxdt = s(y-xy + x - qx^2)\nfracdydt = (-y - xy + z)s\nfracdzdt = w(x - z)\nendalign*","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"with parameter values s=7727, w=0161, and q=8375 times 10^-6, and initial conditions x(0)=1, y(0)=2, and z(0)=3. Use the tutorial on solving ODEs to solve this differential equation on the timespan of tin0360 with the default ODE solver. To investigate the result, plot the solution of all components over time, and plot the phase space plot of the solution (hint: use vars=(1,2,3)). What shape is being drawn in phase space?","category":"page"},{"location":"exercises/stiffbio_uncertainty/#Part-2:-Investigating-Stiffness","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Part 2: Investigating Stiffness","text":"","category":"section"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"Because the reaction rates of q vs s is very large, this model has a \"fast\" system and a \"slow\" system. This is typical of ODEs which exhibit a property known as stiffness. Stiffness changes the ODE solvers which can handle the equation well. Take a look at the ODE solver page and investigate solving the equation using methods for non-stiff equations (ex: Tsit5) and stiff equations (ex: Rodas5).","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"Benchmark using tin050 using @btime from BenchmarkTools.jl. What happens when you increase the timespan?","category":"page"},{"location":"exercises/stiffbio_uncertainty/#(Optional)-Part-3:-Specifying-Analytical-Jacobians-(I)","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"(Optional) Part 3: Specifying Analytical Jacobians (I)","text":"","category":"section"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"Stiff ODE solvers internally utilize the Jacobian of the ODE system in order to improve the stepsizes in the solution. However, computing and factorizing the Jacobian is costly, and thus it can be beneficial to provide the analytical solution.","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"Use the ODEFunction definition page to define an ODEFunction which holds both the OREGO ODE and its Jacobian, and solve using Rodas5.","category":"page"},{"location":"exercises/stiffbio_uncertainty/#(Optional)-Part-4:-Automatic-Symbolicification-and-Analytical-Jacobian-Calculations","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"(Optional) Part 4: Automatic Symbolicification and Analytical Jacobian Calculations","text":"","category":"section"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"Deriving Jacobians by hand is tedious. Thankfully symbolic mathematical systems can do the work for you. And thankfully, DifferentialEquations.jl has tools to automatically convert numerical problems into symbolic problems to perform the analysis on!","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"follow the ModelingToolkit.jl modelingtoolkitize tutorial to automatically convert your ODE definition to its symbolic form using modelingtoolkitize and calculate the analytical Jacobian. Use the compilation functions to build the ODEFunction with the embedded analytical solution.","category":"page"},{"location":"exercises/stiffbio_uncertainty/#Part-5:-Adding-stochasticity-with-stochastic-differential-equations","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Part 5: Adding stochasticity with stochastic differential equations","text":"","category":"section"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"How does this system react in the presense of stochasticity? We can investigate this question by using stochastic differential equations. A stochastic differential equation formulation of this model is known as the multiplicative noise model, is created with:","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"beginalign*\ndx = s(y-xy + x - qx^2)dt + sigma_1 x dW_1\ndy = frac-y - xy + zsdt + sigma_2 y dW_2\ndz = w(x - z)dt + sigma_3 z dW_3\nendalign*","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"with sigma_i = 01 where the dW terms describe a Brownian motion, a continuous random process with normally distributed increments. Use the tutorial on solving SDEs to solve simulate this model. Then, use the EnsembleProblem to generate and plot 100 trajectories of the stochastic model, and use EnsembleSummary to plot the mean and 5%-95% region over time.","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"Try solving with the ImplicitRKMil and SOSRI methods. Notice that it isn't stiff every single time!","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"(For fun, see if you can make the Euler-Maruyama EM() method solve this equation. This requires a choice of dt small enough to be stable. This is the \"standard\" method!)","category":"page"},{"location":"exercises/stiffbio_uncertainty/#Part-6:-Gillespie-jump-models-of-discrete-stochasticity","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Part 6: Gillespie jump models of discrete stochasticity","text":"","category":"section"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"When biological models have very few particles, continuous models no longer make sense, and instead using the full discrete formulation can be required to accuracy describe the dynamics. A discrete differential equation, or Gillespie model, is a continuous-time Markov chain with Poisson-distributed jumps. A discrete description of the Oregonator model is given by a chemical reaction systems:","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"A+Y -> X+P\nX+Y -> 2P\nA+X -> 2X + 2Z\n2X  -> A + P (note: this has rate kX^2!)\nB + Z -> Y","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"where reactions take place at a rate which is propoertional to its components, i.e. the first reaction has a rate k*A*Y for some k. Use the tutorial on Gillespie SSA models to implement the JumpProblem for this model, and use the EnsembleProblem and EnsembleSummary to characterize the stochastic trajectories.","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"For what rate constants does the model give the oscillatory dynamics for the ODE approximation? For information on the true reaction rates, consult the original paper.","category":"page"},{"location":"exercises/stiffbio_uncertainty/#Part-7:-Probabilistic-Programming-/-Bayesian-Parameter-Estimation-with-DiffEqBayes.jl-Turing.jl-(I)","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Part 7: Probabilistic Programming / Bayesian Parameter Estimation with DiffEqBayes.jl + Turing.jl (I)","text":"","category":"section"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"In many cases, one comes to understand the proper values for their model's parameters by utilizing data fitting techniques. In this case, we will use the DiffEqBayes.jl library to perform a Bayesian estimation of the parameters. For our data we will the following potential output:","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"t = 0.0:1.0:30.0\ndata = [1.0 2.05224 2.11422 2.1857 2.26827 2.3641 2.47618 2.60869 2.7677 2.96232 3.20711 3.52709 3.97005 4.64319 5.86202 9.29322 536.068 82388.9 57868.4 1.00399 1.00169 1.00117 1.00094 1.00082 1.00075 1.0007 1.00068 1.00066 1.00065 1.00065 1.00065\n        2.0 1.9494 1.89645 1.84227 1.78727 1.73178 1.67601 1.62008 1.56402 1.50772 1.45094 1.39322 1.33366 1.2705 1.19958 1.10651 0.57194 0.180316 0.431409 251.774 591.754 857.464 1062.78 1219.05 1335.56 1419.88 1478.22 1515.63 1536.25 1543.45 1539.98\n        3.0 2.82065 2.68703 2.58974 2.52405 2.48644 2.47449 2.48686 2.52337 2.58526 2.67563 2.80053 2.9713 3.21051 3.5712 4.23706 12.0266 14868.8 24987.8 23453.4 19202.2 15721.6 12872.0 10538.8 8628.66 7064.73 5784.29 4735.96 3877.66 3174.94 2599.6]","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"Follow the exmaples on the parameter estimation page to perform a Bayesian parameter estimation. What are the most likely parameters for the model given the posterior parameter distributions?","category":"page"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"Use the ODEProblem to perform the fit. If you have time, use the EnsembleProblem of SDEProblems to perform a fit over averages of the SDE solutions. Note that the SDE fit will take significantly more computational resources! See the GPU parallelism section for details on how to accelerate this.","category":"page"},{"location":"exercises/stiffbio_uncertainty/#(Optional)-Part-8:-Using-Catalyst's-Reaction-Network-DSL","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"(Optional) Part 8: Using Catalyst's Reaction Network DSL","text":"","category":"section"},{"location":"exercises/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"Catalyst.jl is a helper library for the DifferentialEquations.jl ecosystem for defining chemical reaction systems at a high leevel for easy simulation in these various forms. Use the descrption from the Chemical Reaction Networks documentation page to build a reaction network and generate the ODE/SDE/jump equations, and compare the result to your handcoded versions.","category":"page"},{"location":"solutions/performance_pde/#Performance-Optimizing-and-Parallelizing-Semilinear-PDE-Solvers-(I)","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"","category":"section"},{"location":"solutions/performance_pde/#Part-1:-Implementing-the-BRUSS-PDE-System-as-ODEs","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 1: Implementing the BRUSS PDE System as ODEs","text":"","category":"section"},{"location":"solutions/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"using DifferentialEquations, Sundials, Plots\n\n# initial condition\nfunction init_brusselator_2d(xyd)\n    N = length(xyd)\n    u = zeros(N, N, 2)\n    for I in CartesianIndices((N, N))\n        x = xyd[I[1]]\n        y = xyd[I[2]]\n        u[I,1] = 22*(y*(1-y))^(3/2)\n        u[I,2] = 27*(x*(1-x))^(3/2)\n    end\n    u\nend\n\nN = 32\n\nxyd_brusselator = range(0,stop=1,length=N)\n\nu0 = vec(init_brusselator_2d(xyd_brusselator))\n\ntspan = (0, 22.)\n\np = (3.4, 1., 10., xyd_brusselator)\n\nbrusselator_f(x, y, t) = ifelse((((x-0.3)^2 + (y-0.6)^2) <= 0.1^2) &&\n                                (t >= 1.1), 5., 0.)\n\n\nusing LinearAlgebra, SparseArrays\ndu = ones(N-1)\nD2 = spdiagm(-1 => du, 0=>fill(-2.0, N), 1 => du)\nD2[1, N] = D2[N, 1] = 1\nD2 = 1/step(xyd_brusselator)^2*D2\ntmp = Matrix{Float64}(undef, N, N)\nfunction brusselator_2d_op(du, u, (D2, tmp, p), t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    α = α/dx^2\n    du = reshape(du, N, N, 2)\n    u = reshape(u, N, N, 2)\n    @views for i in axes(u, 3)\n        ui = u[:, :, i]\n        dui = du[:, :, i]\n        mul!(tmp, D2, ui)\n        mul!(dui, ui, D2')\n        dui .+= tmp\n    end\n\n    @inbounds begin\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n\n            du[i,j,1] = α*du[i,j,1] + B + u[i,j,1]^2*u[i,j,2] - (A + 1)*u[i,j,1] + brusselator_f(x, y, t)\n            du[i,j,2] = α*du[i,j,2] + A*u[i,j,1] - u[i,j,1]^2*u[i,j,2]\n        end\n    end\n    nothing\nend\n\nprob1 = ODEProblem(brusselator_2d_op, u0, tspan, (D2, tmp, p))\n\nsol1 = solve(prob1, TRBDF2(autodiff=false))\nusing BenchmarkTools\n@btime solve(prob1, TRBDF2(autodiff=false));\nreturn nothing #hide","category":"page"},{"location":"solutions/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"Visualizing the solution (works best in a terminal):","category":"page"},{"location":"solutions/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"@gif for t in sol1.t[1]:0.1:sol1.t[end]\n    off = N^2\n    solt = sol1(t)\n    plt1 = surface(reshape(solt[1:off], N, N), zlims=(0, 5), leg=false)\n    surface!(plt1, reshape(solt[off+1:end], N, N), zlims=(0, 5), leg=false)\n    display(plt1)\nend","category":"page"},{"location":"solutions/performance_pde/#Part-2:-Optimizing-the-BRUSS-Code","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 2: Optimizing the BRUSS Code","text":"","category":"section"},{"location":"solutions/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"function brusselator_2d_loop(du, u, p, t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    α = α/dx^2\n    limit = a -> let N=N\n        a == N+1 ? 1 :\n        a == 0 ? N :\n        a\n    end\n    II = LinearIndices((N, N, 2))\n\n    @inbounds begin\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n            ip1 = limit(i+1)\n            im1 = limit(i-1)\n            jp1 = limit(j+1)\n            jm1 = limit(j-1)\n\n            ii1 = II[i,j,1]\n            ii2 = II[i,j,2]\n\n            du[II[i,j,1]] = α*(u[II[im1,j,1]] + u[II[ip1,j,1]] + u[II[i,jp1,1]] + u[II[i,jm1,1]] - 4u[ii1]) +\n            B + u[ii1]^2*u[ii2] - (A + 1)*u[ii1] + brusselator_f(x, y, t)\n\n            du[II[i,j,2]] = α*(u[II[im1,j,2]] + u[II[ip1,j,2]] + u[II[i,jp1,2]] + u[II[i,jm1,2]] - 4u[II[i,j,2]]) +\n            A*u[ii1] - u[ii1]^2*u[ii2]\n        end\n    end\n    nothing\nend\n\nprob2 = ODEProblem(brusselator_2d_loop, u0, tspan, p)\n@btime solve(prob2, TRBDF2());\nreturn nothing #hide","category":"page"},{"location":"solutions/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"@btime solve(prob2, CVODE_BDF());\nreturn nothing #hide","category":"page"},{"location":"solutions/performance_pde/#Part-3:-Exploiting-Jacobian-Sparsity-with-Color-Differentiation","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 3: Exploiting Jacobian Sparsity with Color Differentiation","text":"","category":"section"},{"location":"solutions/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"using Symbolics, SparseDiffTools\n\nsparsity_pattern = Symbolics.jacobian_sparsity(brusselator_2d_loop,similar(u0),u0,p,2.0)\njac_sp = sparse(sparsity_pattern)\njac = Float64.(jac_sp)\ncolors = matrix_colors(jac)\nprob3 = ODEProblem(ODEFunction(brusselator_2d_loop, colorvec=colors,jac_prototype=jac_sp), u0, tspan, p)\n@btime solve(prob3, TRBDF2());\nreturn nothing #hide","category":"page"},{"location":"solutions/performance_pde/#(Optional)-Part-4:-Structured-Jacobians","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"(Optional) Part 4: Structured Jacobians","text":"","category":"section"},{"location":"solutions/performance_pde/#(Optional)-Part-5:-Automatic-Symbolicification-and-Analytical-Jacobian","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"(Optional) Part 5: Automatic Symbolicification and Analytical Jacobian","text":"","category":"section"},{"location":"solutions/performance_pde/#Part-6:-Utilizing-Preconditioned-GMRES-Linear-Solvers","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 6: Utilizing Preconditioned-GMRES Linear Solvers","text":"","category":"section"},{"location":"solutions/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"using DiffEqOperators\nusing Sundials\nusing AlgebraicMultigrid: ruge_stuben, aspreconditioner, smoothed_aggregation\nprob6 = ODEProblem(ODEFunction(brusselator_2d_loop, jac_prototype=JacVecOperator{Float64}(brusselator_2d_loop, u0)), u0, tspan, p)\nII = Matrix{Float64}(I, N, N)\nOp = kron(Matrix{Float64}(I, 2, 2), kron(D2, II) + kron(II, D2))\nWapprox = -I+Op\n#ml = ruge_stuben(Wapprox)\nml = smoothed_aggregation(Wapprox)\nprecond = aspreconditioner(ml)\nsol_trbdf2 = @time solve(prob6, TRBDF2(linsolve=LinSolveGMRES())); # no preconditioner\nsol_trbdf2 = @time solve(prob6, TRBDF2(linsolve=LinSolveGMRES(Pl=lu(Wapprox)))); # sparse LU\nsol_trbdf2 = @time solve(prob6, TRBDF2(linsolve=LinSolveGMRES(Pl=precond))); # AMG\nsol_cvodebdf = @time solve(prob2, CVODE_BDF(linear_solver=:GMRES));","category":"page"},{"location":"solutions/performance_pde/#Part-7:-Exploring-IMEX-and-Exponential-Integrator-Techniques-(E)","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 7: Exploring IMEX and Exponential Integrator Techniques (E)","text":"","category":"section"},{"location":"solutions/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"function laplacian2d(du, u, p, t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    du = reshape(du, N, N, 2)\n    u = reshape(u, N, N, 2)\n    @inbounds begin\n        α = α/dx^2\n        limit = a -> let N=N\n            a == N+1 ? 1 :\n            a == 0 ? N :\n            a\n        end\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n            ip1 = limit(i+1)\n            im1 = limit(i-1)\n            jp1 = limit(j+1)\n            jm1 = limit(j-1)\n            du[i,j,1] = α*(u[im1,j,1] + u[ip1,j,1] + u[i,jp1,1] + u[i,jm1,1] - 4u[i,j,1])\n            du[i,j,2] = α*(u[im1,j,2] + u[ip1,j,2] + u[i,jp1,2] + u[i,jm1,2] - 4u[i,j,2])\n        end\n    end\n    nothing\nend\nfunction brusselator_reaction(du, u, p, t)\n    A, B, α, xyd = p\n    dx = step(xyd)\n    N = length(xyd)\n    du = reshape(du, N, N, 2)\n    u = reshape(u, N, N, 2)\n    @inbounds begin\n        for I in CartesianIndices((N, N))\n            x = xyd[I[1]]\n            y = xyd[I[2]]\n            i = I[1]\n            j = I[2]\n            du[i,j,1] = B + u[i,j,1]^2*u[i,j,2] - (A + 1)*u[i,j,1] + brusselator_f(x, y, t)\n            du[i,j,2] = A*u[i,j,1] - u[i,j,1]^2*u[i,j,2]\n        end\n    end\n    nothing\nend\nprob7 = SplitODEProblem(laplacian2d, brusselator_reaction, u0, tspan, p)\n@btime solve(prob7, KenCarp4());\nreturn nothing #hide","category":"page"},{"location":"solutions/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"M = MatrixFreeOperator((du,u,p)->laplacian2d(du, u, p, 0), (p,), size=(2*N^2, 2*N^2), opnorm=1000)\nprob7_2 = SplitODEProblem(M, brusselator_reaction, u0, tspan, p)\n@btime solve(prob7_2, ETDRK4(krylov=true), dt=1);\nreturn nothing #hide","category":"page"},{"location":"solutions/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"prob7_3 = SplitODEProblem(DiffEqArrayOperator(Op), brusselator_reaction, u0, tspan, p)\n@btime solve(prob7_3, KenCarp4());\nreturn nothing #hide","category":"page"},{"location":"solutions/performance_pde/#Part-8:-Work-Precision-Diagrams-for-Benchmarking-Solver-Choices","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 8: Work-Precision Diagrams for Benchmarking Solver Choices","text":"","category":"section"},{"location":"solutions/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"using DiffEqDevTools\nabstols = 0.1 .^ (5:8)\nreltols = 0.1 .^ (1:4)\nsol = solve(prob3,CVODE_BDF(linear_solver=:GMRES),abstol=1/10^7,reltol=1/10^10)\ntest_sol = TestSolution(sol)\nprobs = [prob2, prob3, prob6]\nsetups = [Dict(:alg=>CVODE_BDF(),:prob_choice => 1),\n          Dict(:alg=>CVODE_BDF(linear_solver=:GMRES), :prob_choice => 1),\n          Dict(:alg=>TRBDF2(), :prob_choice => 1),\n          Dict(:alg=>TRBDF2(linsolve=LinSolveGMRES(Pl=precond)), :prob_choice => 3),\n          Dict(:alg=>TRBDF2(), :prob_choice => 2)\n         ]\nlabels = [\"CVODE_BDF (dense)\" \"CVODE_BDF (GMRES)\" \"TRBDF2 (dense)\" \"TRBDF2 (sparse)\" \"TRBDF2 (GMRES)\"]\nwp = WorkPrecisionSet(probs,abstols,reltols,setups;appxsol=[test_sol,test_sol,test_sol],save_everystep=false,numruns=3,\n  names=labels, print_names=true, seconds=0.5)\nplot(wp)","category":"page"},{"location":"solutions/performance_pde/#Part-9:-GPU-Parallelism-for-PDEs-(E)","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 9: GPU-Parallelism for PDEs (E)","text":"","category":"section"},{"location":"solutions/performance_pde/#Part-10:-Adjoint-Sensitivity-Analysis-for-Gradients-of-PDEs","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 10: Adjoint Sensitivity Analysis for Gradients of PDEs","text":"","category":"section"},{"location":"exercises/dae_double_pendulum/#Differential-Algebraic-Equation-Modeling-of-a-Double-Pendulum-(B)","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"","category":"section"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"Differential-Algebraic Equaton (DAE) systems are like ODEs but allow for adding constraints into the models. This problem will look at solving the double penulum problem with enforcement of the rigid body constraints, requiring that the total distance L is constant throughout the simulation. While these equations can be rewritten in an ODE form, in many cases it can be simpler to solve the equation directly with the constraints. This tutorial will cover both the idea of index, how to manually perform index reduction, and how to make use of mass matrix and implicit ODE solvers to handle these problems.","category":"page"},{"location":"exercises/dae_double_pendulum/#Part-1:-Simple-Introduction-to-DAEs:-Mass-Matrix-Robertson-Equations","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Part 1: Simple Introduction to DAEs: Mass-Matrix Robertson Equations","text":"","category":"section"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"A mass-matrix ordinary differential equation (ODE) is an ODE where the left-hand side, the derivative side, is multiplied by a matrix known as the mass matrix. This is described as:","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"Mu = f(upt)","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"where M is the mass matrix. When M is invertible, there is an ODE which is equivalent to this formulation. When M is not invertible, this can have a distinctly different behavior and is as Differential-Algebraic Equation (DAE).","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"Solve the Robertson DAE:","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"beginalign*\nfracdy_1dt = -004y_1 + 10^4 y_2y_3\nfracdy_2dt =  004y_1 - 10^4 y_2y_3 - 3times 10^7 y_2^2\n1 = y_1 + y_2 + y_3\nendalign*","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"with y(0) = 100 and dy(0) = -00400400 using the mass-matrix formulation and Rodas5(). Use the ODEProblem page to find out how to declare a mass matrix.","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"(Hint: what if the last row has all zeros?)","category":"page"},{"location":"exercises/dae_double_pendulum/#Part-2:-Solving-the-Implicit-Robertson-Equations-with-IDA","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Part 2: Solving the Implicit Robertson Equations with IDA","text":"","category":"section"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"Use the DAE Tutorial to define a DAE in its implicit form and solve the Robertson equation with IDA. Why is differential_vars = [true,true,false]?","category":"page"},{"location":"exercises/dae_double_pendulum/#Part-3:-Manual-Index-Reduction-of-the-Single-Pendulum","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Part 3: Manual Index Reduction of the Single Pendulum","text":"","category":"section"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"The index of a DAE is a notion used to measure distance from its related ODE. There are many different definitions of index, but we're going to stick to the idea of differential index: the number of differentiations required to convert a system of DAEs into explicit ODE form. DAEs of high index are usually transformed via a procedure called index reduction. The following example will demonstrate this.","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"Consider the index 3 DAE system of the cartesian pendulum. After writing down the force equations in both directions, we arrive at the following DAE:","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"beginalign*\nmddotx = fracxLT \nmddoty = fracyLT - mg \nx^2 + y^2 = L\nendalign*","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"Notice that we don't have an equation describing the behaviour of T. Let us now perform index reduction to extract an equation for T","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"Differentiate this third equation twice with respect to time to reduce it from index 3 to index 1.","category":"page"},{"location":"exercises/dae_double_pendulum/#Part-4:-Single-Pendulum-Solution-with-IDA","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Part 4: Single Pendulum Solution with IDA","text":"","category":"section"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"Write these equations in implicit form and solve the system using IDA.","category":"page"},{"location":"exercises/dae_double_pendulum/#Part-5:-Solving-the-Double-Penulum-DAE-System","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Part 5: Solving the Double Penulum DAE System","text":"","category":"section"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"The following equations describe a double pendulum system:","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"beginalign*\nm_2ddotx_2 = fracx_2L_2T_2 \nm_2ddoty_2 = fracy_2L_2T_2 - m_2g \nx_2^2 + y_2^2 = L_2 \nm_1ddotx_1 = fracx_1L_1T_1 - fracx_2L_2T_2 \nm_2ddoty_1 = fracy_1L_1T_2 - m_1g - fracy_2L_2T_2 \nx_1^2 + y_1^2 = L_1 \nendalign*","category":"page"},{"location":"exercises/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"Perform index reduction and solve it like in the previous example.","category":"page"},{"location":"exercises/mtk_chemical_reaction/#ModelingToolkit-Simple-Chemical-Reaction-ODE-(B)","page":"ModelingToolkit Simple Chemical Reaction ODE (B)","title":"ModelingToolkit Simple Chemical Reaction ODE (B)","text":"","category":"section"},{"location":"exercises/mtk_chemical_reaction/","page":"ModelingToolkit Simple Chemical Reaction ODE (B)","title":"ModelingToolkit Simple Chemical Reaction ODE (B)","text":"Implement the following system in ModelingToolkit and solve it with the initial condition:","category":"page"},{"location":"exercises/mtk_chemical_reaction/","page":"ModelingToolkit Simple Chemical Reaction ODE (B)","title":"ModelingToolkit Simple Chemical Reaction ODE (B)","text":"beginalign*\ny1 = 1\ny2 y7 = 0 \ny8 = 00057\nendalign*","category":"page"},{"location":"exercises/mtk_chemical_reaction/","page":"ModelingToolkit Simple Chemical Reaction ODE (B)","title":"ModelingToolkit Simple Chemical Reaction ODE (B)","text":"solve on the interval tin 0 3218122, and plot the solution.","category":"page"},{"location":"exercises/mtk_chemical_reaction/","page":"ModelingToolkit Simple Chemical Reaction ODE (B)","title":"ModelingToolkit Simple Chemical Reaction ODE (B)","text":"beginalign*\nfracmathrmd mathrmy1left( t right)mathrmdt = 00007 + k5 mathrmy2left( t right) + k3 mathrmy3left( t right) - k1 mathrmy1left( t right) \nfracmathrmd mathrmy2left( t right)mathrmdt =  - 875 mathrmy2left( t right) + k1 mathrmy1left( t right) \nfracmathrmd mathrmy3left( t right)mathrmdt =  - 1003 mathrmy3left( t right) + k5 mathrmy4left( t right) + 0035 mathrmy5left( t right) \nfracmathrmd mathrmy4left( t right)mathrmdt = k1 mathrmy3left( t right) + k3 mathrmy2left( t right) - 112 mathrmy4left( t right) \nfracmathrmd mathrmy5left( t right)mathrmdt =  - 1745 mathrmy5left( t right) + k5 mathrmy6left( t right) + k5 mathrmy7left( t right) \nfracmathrmd mathrmy6left( t right)mathrmdt = k1 mathrmy5left( t right) + k4 mathrmy4left( t right) + k4 mathrmy7left( t right) - k5 mathrmy6left( t right) - k2 mathrmy6left( t right) mathrmy8left( t right) \nfracmathrmd mathrmy7left( t right)mathrmdt =  - k6 mathrmy7left( t right) + k2 mathrmy6left( t right) mathrmy8left( t right) \nfracmathrmd mathrmy8left( t right)mathrmdt = k6 mathrmy7left( t right) - k2 mathrmy6left( t right) mathrmy8left( t right)\nendalign*","category":"page"},{"location":"exercises/mtk_chemical_reaction/#Example-Solution-Plot","page":"ModelingToolkit Simple Chemical Reaction ODE (B)","title":"Example Solution Plot","text":"","category":"section"},{"location":"exercises/mtk_chemical_reaction/","page":"ModelingToolkit Simple Chemical Reaction ODE (B)","title":"ModelingToolkit Simple Chemical Reaction ODE (B)","text":"An example of the what the solution should look like is shown below:","category":"page"},{"location":"exercises/mtk_chemical_reaction/","page":"ModelingToolkit Simple Chemical Reaction ODE (B)","title":"ModelingToolkit Simple Chemical Reaction ODE (B)","text":"(Image: )","category":"page"},{"location":"exercises/neural_sde/#Training-Neural-Stochastic-Differential-Equations-with-GPU-acceleration-(I)","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"","category":"section"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"In the previous models we had to define a model. Now let's shift the burden of model-proofing onto data by utilizing neural differential equations. A neural differential equation is a differential equation where the model equations are replaced, either in full or in part, by a neural network. For example, a neural ordinary differential equation is an equation u^prime = f(upt) where f is a neural network. We can learn this neural network from data using various methods, the easiest of which is known as the single shooting method, where one chooses neural network parameters, solves the equation, and checks the ODE's solution against data as a loss.","category":"page"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"In this example we will define and train various forms of neural differential equations. Note that all of the differential equation types are compatible with neural differential equations, so this is only going to scratch the surface of the possibilites!","category":"page"},{"location":"exercises/neural_sde/#Part-1:-Constructing-and-Training-a-Basic-Neural-ODE","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Part 1: Constructing and Training a Basic Neural ODE","text":"","category":"section"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"Use the DiffEqFlux.jl README to construct a neural ODE to train against the training data:","category":"page"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"u0 = Float32[2.; 0.]\ndatasize = 30\ntspan = (0.0f0,1.5f0)\n\nfunction trueODEfunc(du,u,p,t)\n    true_A = [-0.1 2.0; -2.0 -0.1]\n    du .= ((u.^3)'true_A)'\nend\nt = range(tspan[1],tspan[2],length=datasize)\nprob = ODEProblem(trueODEfunc,u0,tspan)\node_data = Array(solve(prob,Tsit5(),saveat=t))","category":"page"},{"location":"exercises/neural_sde/#Part-2:-GPU-accelerating-the-Neural-ODE-Process","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Part 2: GPU-accelerating the Neural ODE Process","text":"","category":"section"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"Use the gpu function from Flux.jl to transform all of the calculations onto the GPU and train the neural ODE using GPU-accelerated Tsit5 with adjoints.","category":"page"},{"location":"exercises/neural_sde/#Part-3:-Defining-and-Training-a-Mixed-Neural-ODE","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Part 3: Defining and Training a Mixed Neural ODE","text":"","category":"section"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"Gather data from the Lotka-Volterra equation:","category":"page"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"function lotka_volterra(du,u,p,t)\n  x, y = u\n  α, β, δ, γ = p\n  du[1] = dx = α*x - β*x*y\n  du[2] = dy = -δ*y + γ*x*y\nend\nu0 = [1.0,1.0]\ntspan = (0.0,10.0)\np = [1.5,1.0,3.0,1.0]\nprob = ODEProblem(lotka_volterra,u0,tspan,p)\nsol = Array(solve(prob,Tsit5())(0.0:1.0:10.0))","category":"page"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"Now use the mixed neural section of the documentation to define the mixed neural ODE where the functional form of fracdxdt is known, and try to derive a neural formulation for fracdydt directly from the data.","category":"page"},{"location":"exercises/neural_sde/#Part-4:-Constructing-a-Basic-Neural-SDE","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Part 4: Constructing a Basic Neural SDE","text":"","category":"section"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"Generate data from the Lotka-Volterra equation with multiplicative noise","category":"page"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"function lotka_volterra(du,u,p,t)\n  x, y = u\n  α, β, δ, γ = p\n  du[1] = dx = α*x - β*x*y\n  du[2] = dy = -δ*y + γ*x*y\nend\nfunction lv_noise(du,u,p,t)\n  du[1] = p[5]*u[1]\n  du[2] = p[6]*u[2]\nend\nu0 = [1.0,1.0]\ntspan = (0.0,10.0)\np = [1.5,1.0,3.0,1.0,0.1,0.1]\nprob = SDEProblem(lotka_volterra,lv_noise,u0,tspan,p)\nsol = [Array(solve(prob,SOSRI())(0.0:1.0:10.0)) for i in 1:20] # 20 solution samples","category":"page"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"Train a neural stochastic differential equation dX = f(X)dt + g(X)dW_t where both the drift (f) and the diffusion (g) functions are neural networks. See if constraining g can make the problem easier to fit.","category":"page"},{"location":"exercises/neural_sde/#Part-5:-Optimizing-the-training-behavior-with-minibatching-(E)","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Part 5: Optimizing the training behavior with minibatching (E)","text":"","category":"section"},{"location":"exercises/neural_sde/","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"Use minibatching on the data to improve the training procedure. An example can be found at this PR.","category":"page"},{"location":"solutions/hybriddelay_pharmacokinetics/#Fitting-Hybrid-Delay-Pharmacokinetic-Models-with-Automated-Responses-(B)","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"","category":"section"},{"location":"solutions/hybriddelay_pharmacokinetics/#Part-1:-Defining-an-ODE-with-Predetermined-Doses","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 1: Defining an ODE with Predetermined Doses","text":"","category":"section"},{"location":"solutions/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"using DifferentialEquations\nusing Plots\nfunction onecompartment(du,u,p,t)\n  Ka,Ke = p\n  du[1] = -Ka*u[1]\n  du[2] =  Ka*u[1] - Ke*u[2]\nend\np = (Ka=2.268,Ke=0.07398)\nprob = ODEProblem(onecompartment,[100.0,0.0],(0.0,90.0),p)\n\ntstops = [24,48,72]\ncondition(u,t,integrator) = t ∈ tstops\naffect!(integrator) = (integrator.u[1] += 100)\ncb = DiscreteCallback(condition,affect!)\nsol = solve(prob,Tsit5(),callback=cb,tstops=tstops)\nplot(sol)","category":"page"},{"location":"solutions/hybriddelay_pharmacokinetics/#Part-2:-Adding-Delays","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 2: Adding Delays","text":"","category":"section"},{"location":"solutions/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"function onecompartment_delay(du,u,h,p,t)\n  Ka,Ke,τ = p\n  delayed_depot = h(p,t-τ)[1]\n  du[1] = -Ka*u[1]\n  du[2] =  Ka*delayed_depot - Ke*u[2]\nend\np = (Ka=2.268,Ke=0.07398,τ=6.0)\nh(p,t) = [0.0,0.0]\nprob = DDEProblem(onecompartment_delay,[100.0,0.0],h,(0.0,90.0),p)\n\ntstops = [24,48,72]\ncondition(u,t,integrator) = t ∈ tstops\naffect!(integrator) = (integrator.u[1] += 100)\ncb = DiscreteCallback(condition,affect!)\nsol = solve(prob,MethodOfSteps(Rosenbrock23()),callback=cb,tstops=tstops)\nplot(sol)","category":"page"},{"location":"solutions/hybriddelay_pharmacokinetics/#Part-3:-Automatic-Differentiation-(AD)-for-Optimization-(I)","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 3: Automatic Differentiation (AD) for Optimization (I)","text":"","category":"section"},{"location":"solutions/hybriddelay_pharmacokinetics/#Part-4:-Fitting-Known-Quantities-with-DiffEqParamEstim.jl-Optim.jl","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 4: Fitting Known Quantities with DiffEqParamEstim.jl + Optim.jl","text":"","category":"section"},{"location":"solutions/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"The data was generated with","category":"page"},{"location":"solutions/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"p = (Ka = 0.5, Ke = 0.1, τ = 4.0)","category":"page"},{"location":"solutions/hybriddelay_pharmacokinetics/#Part-5:-Implementing-Control-Based-Logic-with-ContinuousCallbacks-(I)","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 5: Implementing Control-Based Logic with ContinuousCallbacks (I)","text":"","category":"section"},{"location":"solutions/hybriddelay_pharmacokinetics/#Part-6:-Global-Sensitivity-Analysis-with-the-Morris-and-Sobol-Methods","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 6: Global Sensitivity Analysis with the Morris and Sobol Methods","text":"","category":"section"},{"location":"solutions/neural_sde/#Training-Neural-Stochastic-Differential-Equations-with-GPU-acceleration-(I)","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","text":"","category":"section"},{"location":"solutions/neural_sde/#Part-1:-Constructing-and-Training-a-Basic-Neural-ODE","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Part 1: Constructing and Training a Basic Neural ODE","text":"","category":"section"},{"location":"solutions/neural_sde/#Part-2:-GPU-accelerating-the-Neural-ODE-Process","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Part 2: GPU-accelerating the Neural ODE Process","text":"","category":"section"},{"location":"solutions/neural_sde/#Part-3:-Defining-and-Training-a-Mixed-Neural-ODE","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Part 3: Defining and Training a Mixed Neural ODE","text":"","category":"section"},{"location":"solutions/neural_sde/#Part-4:-Constructing-a-Basic-Neural-SDE","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Part 4: Constructing a Basic Neural SDE","text":"","category":"section"},{"location":"solutions/neural_sde/#Part-5:-Optimizing-the-training-behavior-with-minibatching-(E)","page":"Training Neural Stochastic Differential Equations with GPU acceleration (I)","title":"Part 5: Optimizing the training behavior with minibatching (E)","text":"","category":"section"},{"location":"exercises/performance_pde/#Performance-Optimizing-and-Parallelizing-Semilinear-PDE-Solvers-(I)","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"","category":"section"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"This problem will focus on implementing and optimizing the solution of the 2-dimensional Brusselator equations. The BRUSS equations are a well-known highly stiff oscillatory system of partial differential equations which are used in stiff ODE solver benchmarks. In this tutorial we will walk first through a simple implementation, then do allocation-free implementations and looking deep into solver options and benchmarking.","category":"page"},{"location":"exercises/performance_pde/#Part-1:-Implementing-the-BRUSS-PDE-System-as-ODEs","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 1: Implementing the BRUSS PDE System as ODEs","text":"","category":"section"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"The Brusselator PDE is defined as follows:","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"beginalign*\nfracpartial upartial t = 1 + u^2v - 44u + alpha(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2) + f(x y t)\nfracpartial vpartial t = 34u - u^2v + alpha(fracpartial^2 upartial x^2 + fracpartial^2 upartial y^2)endalign*","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"where","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"f(x y t) =\nbegincases\n5  quad textif  (x-03)^2+(y-06)^2  01^2 text and  t  11 \n0  quad textelse\nendcases","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"and the initial conditions are","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"beginalign*\nu(x y 0) = 22cdot y(1-y)^32 \nv(x y 0) = 27cdot x(1-x)^32\nendalign*","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"with the periodic boundary condition","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"beginalign*\nu(x+1yt) = u(xyt) \nu(xy+1t) = u(xyt)\nendalign*","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"on a timespan of t in 022.","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"To solve this PDE, we will discretize it into a system of ODEs with the finite difference method. We discretize u and v into arrays of the values at each time point: u[i,j] = u(i*dx,j*dy) for some choice of dx/dy, and same for v. Then our ODE is defined with U[i,j,k] = [u v]. The second derivative operator, the Laplacian, discretizes to become a tridiagonal matrix with [1 -2 1] and a 1 in the top right and bottom left corners. The nonlinear functions are then applied at each point in space (they are broadcast). Use dx=dy=1/32.","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"You will know when you have the correct solution when you plot the solution at x=y=0 and see a periodic orbit, e.g., ts=0:0.05:22; plot(ts, sol1.(ts, idxs=1)).","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"If you are not familiar with this process, see the Gierer-Meinhardt example from the SciMLTutorials.","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"Note: Start by doing the simplest implementation!","category":"page"},{"location":"exercises/performance_pde/#Part-2:-Optimizing-the-BRUSS-Code","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 2: Optimizing the BRUSS Code","text":"","category":"section"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"PDEs are expensive to solve, and so we will go nowhere without some code optimizing! Follow the steps described in the the Gierer-Meinhardt example from the SciMLTutorials to optimize your Brusselator code. Try other formulations and see what ends up the fastest! Find a trade-off between performance and simplicity that suits your needs.","category":"page"},{"location":"exercises/performance_pde/#Part-3:-Exploiting-Jacobian-Sparsity-with-Color-Differentiation","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 3: Exploiting Jacobian Sparsity with Color Differentiation","text":"","category":"section"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"Use the sparsity! function from SparseDiffTools to generate the sparsity pattern for the Jacobian of this problem. Follow the documentations on the DiffEqFunction page to specify the sparsity pattern of the Jacobian. Generate an add the color vector to speed up the computation of the Jacobian.","category":"page"},{"location":"exercises/performance_pde/#(Optional)-Part-4:-Structured-Jacobians","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"(Optional) Part 4: Structured Jacobians","text":"","category":"section"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"Specify the sparsity pattern using a BlockBandedMatrix from BlockBandedMatrices.jl to accelerate the previous sparsity handling tricks.","category":"page"},{"location":"exercises/performance_pde/#(Optional)-Part-5:-Automatic-Symbolicification-and-Analytical-Jacobian","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"(Optional) Part 5: Automatic Symbolicification and Analytical Jacobian","text":"","category":"section"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"Use the modelingtoolkitize function from ModelingToolkit.jl to convert your numerical ODE function into a symbolic ODE function and use that to compute and solve with an analytical sparse Jacobian.","category":"page"},{"location":"exercises/performance_pde/#Part-6:-Utilizing-Preconditioned-GMRES-Linear-Solvers","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 6: Utilizing Preconditioned-GMRES Linear Solvers","text":"","category":"section"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"Use the linear solver specification page to solve the equation with TRBDF2 with GMRES. Use the Sundials documentation to solve the equation with CVODE_BDF with Sundials' special internal GMRES. To both of these, use the AlgebraicMultigrid.jl to add a preconditioner to the GMRES solver.","category":"page"},{"location":"exercises/performance_pde/#Part-7:-Exploring-IMEX-and-Exponential-Integrator-Techniques-(E)","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 7: Exploring IMEX and Exponential Integrator Techniques (E)","text":"","category":"section"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"Instead of using the standard ODEProblem, define a SplitODEProblem to move some of the equation to the \"non-stiff part\". Try different splits and solve with KenCarp4 to see if the solution can be accelerated.","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"Next, use MatrixFreeOperator and DiffEqArrayOperator to define part of the equation as linear, and use the ETDRK4 exponential integrator to solve the equation. Note that this technique is not appropriate for this equation since it relies on the nonlinear term being non-stiff for best results.","category":"page"},{"location":"exercises/performance_pde/#Part-8:-Work-Precision-Diagrams-for-Benchmarking-Solver-Choices","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 8: Work-Precision Diagrams for Benchmarking Solver Choices","text":"","category":"section"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"Use the WorkPrecisionSet method from DiffEqDevTools.jl to benchmark multiple different solver methods and find out what combination is most efficient. Take a look at DiffEqBenchmarks.jl for usage examples.","category":"page"},{"location":"exercises/performance_pde/#Part-9:-GPU-Parallelism-for-PDEs-(E)","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 9: GPU-Parallelism for PDEs (E)","text":"","category":"section"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"Fully vectorize your implementation of the ODE and use a CuArray from CuArrays.jl as the initial condition to cause the whole solution to be GPU accelerated.","category":"page"},{"location":"exercises/performance_pde/#Part-10:-Adjoint-Sensitivity-Analysis-for-Gradients-of-PDEs","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Part 10: Adjoint Sensitivity Analysis for Gradients of PDEs","text":"","category":"section"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"In order to optimize the parameters of a PDE, you need to be able to compute the gradient of the solution with respect to the parameters. This is done through sensitivity analysis. For PDEs, generally the system is at a scale where forward sensitivity analysis (forward-mode automatic differentiation) is no longer suitable, and for these cases one uses adjoint sensitivity analysis.","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"Rewrite the PDE so the constant terms are parameters, and use the adjoint sensitivity analysis documentation to solve for the solution gradient with a cost function being the L2 distance of the solution from the value 1. Solve with interpolated and checkpointed adjoints. Play with using reverse-mode automatic differentiation vs direct computation of vector-Jacobian products using the autojacvec option of the SensitivityAlg. Find the set of options most suitable for this PDE.","category":"page"},{"location":"exercises/performance_pde/","page":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","title":"Performance Optimizing and Parallelizing Semilinear PDE Solvers (I)","text":"If you have compute time, use this adjoint to optimize the parameters of the PDE with respect to this cost function.","category":"page"},{"location":"solutions/stiffbio_uncertainty/#Investigating-Sources-of-Randomness-and-Uncertainty-in-a-Stiff-Biological-System-(B)","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"","category":"section"},{"location":"solutions/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"using DifferentialEquations\nusing Sundials\nusing BenchmarkTools\nusing Plots","category":"page"},{"location":"solutions/stiffbio_uncertainty/#Part-1:-Simulating-the-Oregonator-ODE-model","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Part 1: Simulating the Oregonator ODE model","text":"","category":"section"},{"location":"solutions/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"using DifferentialEquations, Plots\nfunction orego(du,u,p,t)\n  s,q,w = p\n  y1,y2,y3 = u\n  du[1] = s*(y2+y1*(1-q*y1-y2))\n  du[2] = (y3-(1+y1)*y2)/s\n  du[3] = w*(y1-y3)\nend\np = [77.27,8.375e-6,0.161]\nprob = ODEProblem(orego,[1.0,2.0,3.0],(0.0,360.0),p)\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"solutions/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"plot(sol,idxs=(1,2,3))","category":"page"},{"location":"solutions/stiffbio_uncertainty/#Part-2:-Investigating-Stiffness","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Part 2: Investigating Stiffness","text":"","category":"section"},{"location":"solutions/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"using BenchmarkTools\nprob = ODEProblem(orego,[1.0,2.0,3.0],(0.0,50.0),p)\n@btime sol = solve(prob,Tsit5());\nreturn nothing #hide","category":"page"},{"location":"solutions/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"@btime sol = solve(prob,Rodas5());\nreturn nothing #hide","category":"page"},{"location":"solutions/stiffbio_uncertainty/#(Optional)-Part-3:-Specifying-Analytical-Jacobians-(I)","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"(Optional) Part 3: Specifying Analytical Jacobians (I)","text":"","category":"section"},{"location":"solutions/stiffbio_uncertainty/#(Optional)-Part-4:-Automatic-Symbolicification-and-Analytical-Jacobian-Calculations","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"(Optional) Part 4: Automatic Symbolicification and Analytical Jacobian Calculations","text":"","category":"section"},{"location":"solutions/stiffbio_uncertainty/#Part-5:-Adding-stochasticity-with-stochastic-differential-equations","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Part 5: Adding stochasticity with stochastic differential equations","text":"","category":"section"},{"location":"solutions/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"function orego(du,u,p,t)\n  s,q,w = p\n  y1,y2,y3 = u\n  du[1] = s*(y2+y1*(1-q*y1-y2))\n  du[2] = (y3-(1+y1)*y2)/s\n  du[3] = w*(y1-y3)\nend\nfunction g(du,u,p,t)\n  du[1] = 0.1u[1]\n  du[2] = 0.1u[2]\n  du[3] = 0.1u[3]\nend\np = [77.27,8.375e-6,0.161]\nprob = SDEProblem(orego,g,[1.0,2.0,3.0],(0.0,30.0),p)\nsol = solve(prob,SOSRI())\nplot(sol)","category":"page"},{"location":"solutions/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"sol = solve(prob,ImplicitRKMil()); plot(sol)","category":"page"},{"location":"solutions/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"sol = solve(prob,ImplicitRKMil()); plot(sol)","category":"page"},{"location":"solutions/stiffbio_uncertainty/#Part-6:-Gillespie-jump-models-of-discrete-stochasticity","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Part 6: Gillespie jump models of discrete stochasticity","text":"","category":"section"},{"location":"solutions/stiffbio_uncertainty/#Part-7:-Probabilistic-Programming-/-Bayesian-Parameter-Estimation-with-DiffEqBayes.jl-Turing.jl-(I)","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Part 7: Probabilistic Programming / Bayesian Parameter Estimation with DiffEqBayes.jl + Turing.jl (I)","text":"","category":"section"},{"location":"solutions/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"The data was generated with:","category":"page"},{"location":"solutions/stiffbio_uncertainty/","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","text":"function orego(du,u,p,t)\n  s,q,w = p\n  y1,y2,y3 = u\n  du[1] = s*(y2+y1*(1-q*y1-y2))\n  du[2] = (y3-(1+y1)*y2)/s\n  du[3] = w*(y1-y3)\nend\np = [60.0,1e-5,0.2]\nprob = ODEProblem(orego,[1.0,2.0,3.0],(0.0,30.0),p)\nsol = solve(prob,Rodas5(),abstol=1/10^14,reltol=1/10^14)\nplot(sol)","category":"page"},{"location":"solutions/stiffbio_uncertainty/#(Optional)-Part-8:-Using-DiffEqBiological's-Reaction-Network-DSL","page":"Investigating Sources of Randomness and Uncertainty in a Stiff Biological System (B)","title":"(Optional) Part 8: Using DiffEqBiological's Reaction Network DSL","text":"","category":"section"},{"location":"exercises/dc_motor_control/#Controlling-a-DC-Motor-(E)","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"","category":"section"},{"location":"exercises/dc_motor_control/#Part-1-(Optional):-Build-the-DC-Motor-System-using-the-ModelingToolkit-Standard-Library","page":"Controlling a DC Motor (E)","title":"Part 1 (Optional): Build the DC Motor System using the ModelingToolkit Standard Library","text":"","category":"section"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"(Image: )","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"where R = 05Omega L = 45times 10^-3 H k = 05 Ncdot mA J = 002 textkg cdot m^2 f = 001 Ncdot mcdot stextrad. R is the armature resistance, L is the armature inductance, k is the motor constant, J is inertia, and f is the friction factor.","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"To test the DC motor, hook it up to a constant voltage signal 5 V and a constant load 1 Nm.","category":"page"},{"location":"exercises/dc_motor_control/#Example-Solution-Plot","page":"Controlling a DC Motor (E)","title":"Example Solution Plot","text":"","category":"section"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"(Image: )","category":"page"},{"location":"exercises/dc_motor_control/#Part-2:-Add-a-controller","page":"Controlling a DC Motor (E)","title":"Part 2: Add a controller","text":"","category":"section"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"Make use of the Blocks.LimPI and Blocks.Feedback from ModelingToolkitStandardLibrary to close the loop around the motor model using a PI controller. The following is a block diagram of the construction:","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"                                 +-----+     +-----+\n                            r    |     |  u  |     | y\n                            --+->|  C  +---->|  P  +-+->\n                             -|  |     |     |     | |\n                              |  +-----+     +-----+ |\n                              |                      |\n                              +----------------------+","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"Simulate the system and plot the response to a unit step in the reference and, if you feel ambitious, a step in load disturbance appearing on the plant input as well.","category":"page"},{"location":"exercises/dc_motor_control/#Part-3:-Tune/detune-the-controller","page":"Controlling a DC Motor (E)","title":"Part 3: Tune/detune the controller","text":"","category":"section"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"ModelingToolkit supports inserting analysis points into models to facilitate linear analysis. An analysis point can be viewed as a named connection of particular interest for causal linear analysis. An example use case for analysis points is to derive sensitivity functions. An analysis point is created automatically if a connection is named using the syntax connect(output, :name, input).","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"The documentation for analysis points is available here","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"note: Note\nthe analysis point connections are inherently causal, the order of the connected signals in an analysis-point connection is thus important. The wrong causality may cause a sensitivity function to turn into a complementary sensitivity function.","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"Let the linearized system model be described by the transfer function P(s) and the linearized controller by C(s), derive the sensitivity function:","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"S(s) = dfrac11 + P(s)C(s)","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"at the plant output and plot the Bode diagram.","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"To accomplish this, see functions:","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"using ControlSystemsBase\nmatrices, simplifiedsystem = getsensitivity(sys, analysispointname)`. This function is nice enough to linearize the system automatically.\nss to create a linear state-space system. The matrices to create the state-space model are given by the call above.\nbodeplot","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"Try to tune the controller by changing the controller gain k and the integration time T in the PI-controller (LimPI) such that the closed-loop system becomes unstable. Watch how the sensitivity function changes as you reduce the stability margin. The documentation for the Block library of ModelingToolkitStandardLibrary is available here","category":"page"},{"location":"exercises/dc_motor_control/#Part-4-(Optional):-Plot-the-Nyquist-curve-for-the-loop-transfer-function","page":"Controlling a DC Motor (E)","title":"Part 4 (Optional): Plot the Nyquist curve for the loop-transfer function","text":"","category":"section"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"The loop-transfer function (at the input or output of the plant), may be computed using the function get_looptransfer(sys, analysis_point_name). Create a linear state-space model representing the loop-transfer function in a similar fashion to how the sensitivity function was created above, and plot the Nyquist curve using the command nyquistplot.","category":"page"},{"location":"exercises/dc_motor_control/#Example-Solution-Plot-2","page":"Controlling a DC Motor (E)","title":"Example Solution Plot","text":"","category":"section"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"With the PI-controller tuned like k = 11 T = 005 u_max = 10 T_a = 0035, the plots should look like:","category":"page"},{"location":"exercises/dc_motor_control/","page":"Controlling a DC Motor (E)","title":"Controlling a DC Motor (E)","text":"(Image: )","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/#Fitting-Hybrid-Delay-Pharmacokinetic-Models-with-Automated-Responses-(B)","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"","category":"section"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"Hybrid differential equations are differential equations with events, where events are some interaction that occurs according to a prespecified condition. For example, the bouncing ball is a classic hybrid differential equation given by an ODE (Newton's Law of Gravity) mixed with the fact that, whenever the ball hits the floor (x=0), then the velocity of the ball flips (v=-v).","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"In addition, many models incorporate delays, that is the driving force of the equation is dependent not on the current values, but values from the past. These delay differential equations model how individuals in the economy act on old information, or that biological processes take time to adapt to a new environment.","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"In this equation we will build a hybrid delayed pharmacokinetic model and use the parameter estimation techniques to fit this it to a data.","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/#Part-1:-Defining-an-ODE-with-Predetermined-Doses","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 1: Defining an ODE with Predetermined Doses","text":"","category":"section"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"First, let's define the simplest hybrid ordinary differential equation: an ODE where the events take place at fixed times. The ODE we will use is known as the one-compartment model:","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"beginalign*\nfracdDepotdt = -K_a Depot + R\nfracdCentraldt = K_a Depot - K_e Central\nendalign*","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"with t in 090, u_0 = 10000, and p=K_aK_e=2268007398.","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"With this model, use the event handling documentation page to define a DiscreteCallback which fires at t ∈ [24,48,72] and adds a dose of 100 into [Depot]. (Hint: you'll want to set tstops=[24,48,72] to force the ODE solver to step at these times).","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/#Part-2:-Adding-Delays","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 2: Adding Delays","text":"","category":"section"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"Now let's assume that instead of there being one compartment, there are many transit compartment that the drug must move through in order to reach the central compartment. This effectively delays the effect of the transition from [Depot] to [Central]. To model this effect, we will use the delay differential equation which utilizes a fixed time delay tau:","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"beginalign*\nfracdDepotdt = -K_a Depot(t)\nfracdCentraldt = K_a Depot(t-tau) - K_e Central\nendalign*","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"where the parameter τ = 60. Use the DDE tutorial to define and solve this delayed version of the hybrid model.","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/#Part-3:-Automatic-Differentiation-(AD)-for-Optimization-(I)","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 3: Automatic Differentiation (AD) for Optimization (I)","text":"","category":"section"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"In order to fit parameters (K_aK_etau) we will want to be able to calculate the gradient of the solution with respect to the initial conditions. One way to do this is via Automatic Differentition (AD). For small numbers of parameters (<100), it is fastest to use Forward-Mode Automatic Differentition (even faster than using adjoint sensitivity analysis!). Thus for this problem we will make use of ForwardDiff.jl to use Dual number arithmetic to retrive both the solution and its derivative w.r.t. parameters in a single solve.","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"Use the information from the page on local sensitvity analysis to define the input dual numbers, solve the equation, and plot both the solution over time and the derivative of the solution w.r.t. the parameters.","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/#Part-4:-Fitting-Known-Quantities-with-DiffEqParamEstim.jl-Optim.jl","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 4: Fitting Known Quantities with DiffEqParamEstim.jl + Optim.jl","text":"","category":"section"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"Now let's fit the delayed model to a dataset. For the data, use the array","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"t = 0.0:12.0:90.0\ndata = [100.0 0.246196 0.000597933 0.24547 0.000596251 0.245275 0.000595453 0.245511\n        0.0 53.7939 16.8784 58.7789 18.3777 59.1879 18.5003 59.2611]","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"Use the parameter estimation page to define a loss function with build_loss_objective and optimize the parameters against the data. What parameters were used to generate the data?","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/#Part-5:-Implementing-Control-Based-Logic-with-ContinuousCallbacks-(I)","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 5: Implementing Control-Based Logic with ContinuousCallbacks (I)","text":"","category":"section"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"Now that we have fit our delay differential equation model to the dataset, we want to start testing out automated treatment strategies. Let's assume that instead of giving doses at fixed time points, we invent a wearable which monitors the patient and administers a dose whenever the internal drug concentration falls below 25. To model this effect, we will need to use ContinuousCallbacks to define a callback that triggers when [Central] falls below the threshold value.","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"Use the documentation on the event handling page to define such a callback, and plot the solution over time. How many times does the auto-doser administer a dose? How much does this change as you change the delay time tau?","category":"page"},{"location":"exercises/hybriddelay_pharmacokinetics/#Part-6:-Global-Sensitivity-Analysis-with-the-Morris-and-Sobol-Methods","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Part 6: Global Sensitivity Analysis with the Morris and Sobol Methods","text":"","category":"section"},{"location":"exercises/hybriddelay_pharmacokinetics/","page":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","title":"Fitting Hybrid Delay Pharmacokinetic Models with Automated Responses (B)","text":"To understand how the parameters effect the solution in a global sense, one wants to use Global Sensitivity Analysis. Use the GSA documentation page perform global sensitivity analysis and quantify the effect of the various parameters on the solution.","category":"page"},{"location":"solutions/dae_double_pendulum/#Differential-Algebraic-Equation-Modeling-of-a-Double-Pendulum-(B)","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"","category":"section"},{"location":"solutions/dae_double_pendulum/#Part-1:-Simple-Introduction-to-DAEs:-Mass-Matrix-Robertson-Equations","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Part 1: Simple Introduction to DAEs: Mass-Matrix Robertson Equations","text":"","category":"section"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"using DifferentialEquations, Plots, Sundials\n\nfunction f(du, u, p, t)\n    du[1] = -p[1]*u[1] + p[2]*u[2]*u[3]\n    du[2] = p[1]*u[1] - p[2]*u[2]*u[3] - p[3]*u[2]*u[2]\n    du[3] = u[1] + u[2] + u[3] - 1.\nend\nM = [1 0 0; 0 1 0; 0 0 0.]\np = [0.04, 10^4, 3e7]\nu0 = [1.,0.,0.]\ntspan = (0., 1e6)\nprob = ODEProblem(ODEFunction(f, mass_matrix = M), u0, tspan, p)\nsol = solve(prob, Rodas5())\nplot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1))","category":"page"},{"location":"solutions/dae_double_pendulum/#Part-2:-Solving-the-Implicit-Robertson-Equations-with-IDA","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Part 2: Solving the Implicit Robertson Equations with IDA","text":"","category":"section"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"# Robertson Equation DAE Implicit form\nfunction h(out, du, u, p, t)\n    out[1] = -p[1]*u[1] + p[2]*u[2]*u[3] - du[1]\n    out[2] = p[1]*u[1] - p[2]*u[2]*u[3] - p[3]*u[2]*u[2] - du[2]\n    out[3] = u[1] + u[2] + u[3] - 1.\nend\np = [0.04, 10^4, 3e7]\ndu0 = [-0.04, 0.04, 0.0]\nu0 = [1.,0.,0.]\ntspan = (0., 1e6)\ndifferential_vars = [true, true, false]\nprob = DAEProblem(h, du0, u0, tspan, p, differential_vars = differential_vars)\nsol = solve(prob, IDA())\nplot(sol, xscale=:log10, tspan=(1e-6, 1e5), layout=(3,1))","category":"page"},{"location":"solutions/dae_double_pendulum/#Part-3:-Manual-Index-Reduction-of-the-Single-Pendulum","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Part 3: Manual Index Reduction of the Single Pendulum","text":"","category":"section"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"Consider the equation: $ x^2 + y^2 = L $ Differentiating once with respect to time: $ 2x\\dot{x} + 2y\\dot{y} = 0 $ A second time:","category":"page"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"beginalign*\ndotx^2 + xddotx + doty^2 + yddoty = 0  \nu^2 + v^2 + x(fracxmLT) + y(fracymLT - g) = 0  \nu^2 + v^2 + fracx^2 + y^2mLT - yg = 0 \nu^2 + v^2 + fracTm - yg = 0\nendalign*","category":"page"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"Our final set of equations is hence","category":"page"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"beginalign*\n   ddotx = fracxmLT \n   ddoty = fracymLT - g \n   dotx = u \n   doty = v \n   u^2 + v^2 -yg + fracTm = 0\nendalign*","category":"page"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"We finally obtain T into the third equation. This required two differentiations with respect to time, and so our system of equations went from index 3 to index 1. Now our solver can handle the index 1 system.","category":"page"},{"location":"solutions/dae_double_pendulum/#Part-4:-Single-Pendulum-Solution-with-IDA","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Part 4: Single Pendulum Solution with IDA","text":"","category":"section"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"function f(out, da, a, p, t)\n   (L, m, g) = p\n   u, v, x, y, T = a\n   du, dv, dx, dy, dT = da\n   out[1] = x*T/(m*L) - du\n   out[2] = y*T/(m*L) - g - dv\n   out[3] = u - dx\n   out[4] = v - dy\n   out[5] = u^2 + v^2 - y*g + T/m\n   nothing\nend\n\n# Release pendulum from top right\nu0 = zeros(5)\nu0[3] = 1.0\ndu0 = zeros(5)\ndu0[2] = 9.81\n\np = [1,1,9.8]\ntspan = (0.,100.)\n\ndifferential_vars = [true, true, true, true, false]\nprob = DAEProblem(f, du0, u0, tspan, p, differential_vars = differential_vars)\nsol = solve(prob, IDA())\nplot(sol, idxs=(3,4))","category":"page"},{"location":"solutions/dae_double_pendulum/#Part-5:-Solving-the-Double-Penulum-DAE-System","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Part 5: Solving the Double Penulum DAE System","text":"","category":"section"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"For the double pendulum: The equations for the second ball are the same as the single pendulum case. That is, the equations for the second ball are:","category":"page"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"beginalign*\n   ddotx_2 = fracx_2m_2L_2T_2 \n   ddoty_2 = fracy_2m_2L_2T_2 - g \n   dotx_2 = u \n   doty_2 = v \n   u_2^2 + v_2^2 -y_2g + fracT_2m_2 = 0\nendalign*","category":"page"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"For the first ball, consider x_1^2 + y_1^2 = L $","category":"page"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"beginalign*\nx_1^2 + x_2^2 = L \n2x_1dotx_1 + 2y_1doty_1 = 0 \ndotx_1^2 + doty_1^2 + x_1(fracx_1m_1L_1T_1 - fracx_2m_1L_2T_2) + y_1(fracy_1m_1L_1T_1 - g - fracy_2m_1L_2T_2) = 0 \nu_1^2 + v_1^2 + fracT_1m_1 - fracx_1x_2 + y_1y_2m_1L_2T_2 = 0\nendalign*","category":"page"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"So the final equations are:","category":"page"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"beginalign*\n   dotu_2 = x_2*T_2(m_2*L_2)\n   dotv_2 = y_2*T_2(m_2*L_2) - g\n   dotx_2 = u_2\n   doty_2 = v_2\n   u_2^2 + v_2^2 -y_2*g + fracT_2m_2 =  0\n\n   dotu_1 = x_1*T_1(m_1*L_1) - x_2*T_2(m_2*L_2)\n   dotv_1 = y_1*T_1(m_1*L_1) - g - y_2*T_2(m_2*L_2)\n   dotx_1 = u_1\n   doty_1 = v_1\n   u_1^2 + v_1^2 + fracT_1m_1 +\n                frac-x_1*x_2 - y_1*y_2m_1L_2T_2 - y_1g = 0\nendalign*","category":"page"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"function f(out, da, a, p, t)\n   L1, m1, L2, m2, g = p\n\n   u1, v1, x1, y1, T1,\n   u2, v2, x2, y2, T2 = a\n\n   du1, dv1, dx1, dy1, dT1,\n   du2, dv2, dx2, dy2, dT2 = da\n\n   out[1]  = x2*T2/(m2*L2) - du2\n   out[2]  = y2*T2/(m2*L2) - g - dv2\n   out[3]  = u2 - dx2\n   out[4]  = v2 - dy2\n   out[5]  = u2^2 + v2^2 -y2*g + T2/m2\n\n   out[6]  = x1*T1/(m1*L1) - x2*T2/(m2*L2) - du1\n   out[7]  = y1*T1/(m1*L1) - g - y2*T2/(m2*L2) - dv1\n   out[8]  = u1 - dx1\n   out[9]  = v1 - dy1\n   out[10] = u1^2 + v1^2 + T1/m1 +\n                (-x1*x2 - y1*y2)/(m1*L2)*T2 - y1*g\n   nothing\nend\n\n# Release pendulum from top right\nu0 = zeros(10)\nu0[3] = 1.0\nu0[8] = 1.0\ndu0 = zeros(10)\ndu0[2] = 9.8\ndu0[7] = 9.8\n\np = [1,1,1,1,9.8]\ntspan = (0.,100.)\n\ndifferential_vars = [true, true, true, true, false,\n                     true, true, true, true, false]\nprob = DAEProblem(f, du0, u0, tspan, p, differential_vars = differential_vars)\nsol = solve(prob, IDA())\n\nplot(sol, idxs=(3,4))","category":"page"},{"location":"solutions/dae_double_pendulum/","page":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","title":"Differential-Algebraic Equation Modeling of a Double Pendulum (B)","text":"plot(sol, idxs=(8,9))","category":"page"},{"location":"exercises/acausal_circuit/#RLC-Circuit-Acausal-Model-(I)","page":"RLC Circuit Acausal Model (I)","title":"RLC Circuit Acausal Model (I)","text":"","category":"section"},{"location":"exercises/acausal_circuit/","page":"RLC Circuit Acausal Model (I)","title":"RLC Circuit Acausal Model (I)","text":"Use the RC circuit tutorial from the ModelingToolkit documentation and extend it to create the RLC circuit.","category":"page"},{"location":"exercises/acausal_circuit/","page":"RLC Circuit Acausal Model (I)","title":"RLC Circuit Acausal Model (I)","text":"An ideal inductor is characterized by fracdIdt = fracVL. An ideal capacitor is characterized byfracdVdt = fracIC. An ideal resistor is characterized by V = IR. Use R = L = C = V = 1.","category":"page"},{"location":"exercises/acausal_circuit/","page":"RLC Circuit Acausal Model (I)","title":"RLC Circuit Acausal Model (I)","text":"(Image: )","category":"page"},{"location":"exercises/acausal_circuit/#Example-Solution-Plot","page":"RLC Circuit Acausal Model (I)","title":"Example Solution Plot","text":"","category":"section"},{"location":"exercises/acausal_circuit/","page":"RLC Circuit Acausal Model (I)","title":"RLC Circuit Acausal Model (I)","text":"An example of the what the solution should look like is shown below:","category":"page"},{"location":"exercises/acausal_circuit/","page":"RLC Circuit Acausal Model (I)","title":"RLC Circuit Acausal Model (I)","text":"(Image: )","category":"page"},{"location":"solutions/acausal_circuit/#RLC-Circuit-Acausal-Model-(I)","page":"RLC Circuit Acausal Model (I)","title":"RLC Circuit Acausal Model (I)","text":"","category":"section"},{"location":"solutions/acausal_circuit/","page":"RLC Circuit Acausal Model (I)","title":"RLC Circuit Acausal Model (I)","text":"module RLC\n\nusing ModelingToolkit\n\n@variables t\n@connector function Pin(;name)\n    sts = @variables v(t)=1.0 i(t)=1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(;name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction OnePort(;name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t)=1.0 i(t)=1.0\n    eqs = [\n           v ~ p.v - n.v\n           0 ~ p.i + n.i\n           i ~ p.i\n          ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(;name, R = 1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R=R\n    eqs = [\n           v ~ i * R\n          ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Capacitor(;name, C = 1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters C=C\n    D = Differential(t)\n    eqs = [\n           D(v) ~ i / C\n          ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Inductor(; name, L = 1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters L = L\n    D = Differential(t)\n    eqs = [\n        D(i) ~ v / L,\n    ]\n    extend(ODESystem(eqs, t, [], ps; name = name), oneport)\nend\n\nfunction ConstantVoltage(;name, V = 1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V=V\n    eqs = [\n           V ~ v\n          ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nend\n\nusing .RLC\nusing ModelingToolkit, Plots, DifferentialEquations\nL = C = V = R = 1.0\n@named inductor = RLC.Inductor(L=L)\n@named resistor = RLC.Resistor(R=R)\n@named capacitor = RLC.Capacitor(C=C)\n@named source = RLC.ConstantVoltage(V=V)\n@named ground = RLC.Ground()\n\nrlc_eqs = [\n          connect(source.p, resistor.p)\n          connect(resistor.n, inductor.p)\n          connect(inductor.n, capacitor.p)\n          connect(capacitor.n, source.n)\n          connect(capacitor.n, ground.g)\n         ]\n\n@named _rlc_model = ODESystem(rlc_eqs, RLC.t)\n@named rlc_model = compose(_rlc_model,\n                          [inductor, resistor, capacitor, source, ground])\nsys = structural_simplify(rlc_model)\nu0 = [\n      capacitor.v => 0.0\n     ]\nprob = ODEProblem(sys, u0, (0, 10.0))\nsol = solve(prob)\nplot(sol)","category":"page"},{"location":"solutions/gsa_henon_heiles/#Global-Parameter-Sensitivity-and-Optimality-with-GPU-and-Distributed-Ensembles-(B)","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"","category":"section"},{"location":"solutions/gsa_henon_heiles/#Part-1:-Implementing-the-Henon-Heiles-System-(B)","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Part 1: Implementing the Henon-Heiles System (B)","text":"","category":"section"},{"location":"solutions/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"using DifferentialEquations, Plots, DiffEqPhysics\n\nfunction henon(dz,z,p,t)\n  p₁, p₂, q₁, q₂ = z[1], z[2], z[3], z[4]\n  dp₁ = -q₁*(1 + 2q₂)\n  dp₂ = -q₂-(q₁^2 - q₂^2)\n  dq₁ = p₁\n  dq₂ = p₂\n\n  dz .= [dp₁, dp₂, dq₁, dq₂]\n  return nothing\nend\n\nu₀ = [0.1, 0.0, 0.0, 0.5]\nprob = ODEProblem(henon, u₀, (0., 1000.))\nsol = solve(prob, Vern9(), abstol=1e-14, reltol=1e-14)\n\nplot(sol, idxs=[(3,4,1)], tspan=(0,100))","category":"page"},{"location":"solutions/gsa_henon_heiles/#(Optional)-Part-2:-Alternative-Dynamical-Implmentations-of-Henon-Heiles-(B)","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"(Optional) Part 2: Alternative Dynamical Implmentations of Henon-Heiles (B)","text":"","category":"section"},{"location":"solutions/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"function henon(ddz,dz,z,p,t)\n  p₁, p₂ = dz[1], dz[2]\n  q₁, q₂ = z[1], z[2]\n  ddq₁ = -q₁*(1 + 2q₂)\n  ddq₂ = -q₂-(q₁^2 - q₂^2)\n\n  ddz .= [ddq₁, ddq₂]\nend\n\np₀ = u₀[1:2]\nq₀ = u₀[3:4]\nprob2 = SecondOrderODEProblem(henon, p₀, q₀, (0., 1000.))\nsol = solve(prob2, DPRKN6(), abstol=1e-10, reltol=1e-10)\n\nplot(sol, vars=[(3,4)], tspan=(0,100))","category":"page"},{"location":"solutions/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"H(p, q, params) = 1/2 * (p[1]^2 + p[2]^2) + 1/2 * (q[1]^2 + q[2]^2 + 2q[1]^2 * q[2] - 2/3*q[2]^3)\n\nprob3 = HamiltonianProblem(H, p₀, q₀, (0., 1000.))\nsol = solve(prob3, DPRKN6(), abstol=1e-10, reltol=1e-10)\n\nplot(sol, idxs=[(3,4)], tspan=(0,100))","category":"page"},{"location":"solutions/gsa_henon_heiles/#Part-3:-Parallelized-Ensemble-Solving","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Part 3: Parallelized Ensemble Solving","text":"","category":"section"},{"location":"solutions/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"In order to solve with an ensamble we need some initial conditions.","category":"page"},{"location":"solutions/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"function generate_ics(E,n)\n  # The hardcoded values bellow can be estimated by looking at the\n  # figures in the Henon-Heiles 1964 article\n  qrange = range(-0.4, stop = 1.0, length = n)\n  prange = range(-0.5, stop = 0.5, length = n)\n  z0 = Vector{Vector{typeof(E)}}()\n  for q in qrange\n    V = H([0,0],[0,q],nothing)\n    V ≥ E && continue\n    for p in prange\n      T = 1/2*p^2\n      T + V ≥ E && continue\n      z = [√(2(E-V-T)), p, 0, q]\n      push!(z0, z)\n    end\n  end\n  return z0\nend\n\nz0 = generate_ics(0.125, 10)\n\nfunction prob_func(prob,i,repeat)\n  @. prob.u0 = z0[i]\n  prob\nend\n\nensprob = EnsembleProblem(prob, prob_func=prob_func)\nsim = solve(ensprob, Vern9(), EnsembleThreads(), trajectories=length(z0))\n\nplot(sim, idxs=(3,4), tspan=(0,10))","category":"page"},{"location":"solutions/gsa_henon_heiles/#Part-4:-Parallelized-GPU-Ensemble-Solving","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Part 4: Parallelized GPU Ensemble Solving","text":"","category":"section"},{"location":"solutions/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"In order to use GPU parallelization we must make all inputs (initial conditions, tspan, etc.) Float32 and the function definition should be in the in-place form, avoid bound checking and return nothing.","category":"page"},{"location":"solutions/gsa_henon_heiles/","page":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","title":"Global Parameter Sensitivity and Optimality with GPU and Distributed Ensembles (B)","text":"using DiffEqGPU\n\nfunction henon_gpu(z,p,t)\n  @inbounds begin\n    dz1 = -z[3]*(1 + 2z[4])\n    dz2 = -z[4]-(z[3]^2 - z[4]^2)\n    dz3 = z[1]\n    dz4 = z[2]\n  end\n  return SA[dz1,dz2,dz3,dz4]\nend\n\nz0 = SA[generate_ics(0.125f0, 50)...]\nprob_gpu = ODEProblem(henon_gpu, Float32.(u₀), (0.f0, 1000.f0))\nensprob = EnsembleProblem(prob_gpu, prob_func=prob_func)\nsim = solve(ensprob, GPUTsit5(), EnsembleGPUKernel(), trajectories=length(z0))","category":"page"},{"location":"#SciMLWorkshop:-Workshop-Materials-for-Training-in-Scientific-Computing-and-Scientific-Machine-Learning-(SciML)","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"","category":"section"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"These exercises teach common workflows which involve SciML's tools like DifferentialEquations.jl, ModelingToolkit.jl DiffEqFlux.jl, and the connections to parts like stochastic differential equations and Bayesian estimation.","category":"page"},{"location":"#Difficulty-Levels","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"Difficulty Levels","text":"","category":"section"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"The designation (B) is for \"Beginner\", meaning that a user new to the package should feel comfortable trying this exercise. An exercise designated (I) is for \"Intermediate\", meaning the user may want to have some previous background in DifferentialEquations.jl or try some (B) exercises first. The additional (E) designation is for \"Experienced\", which are portions of exercises which may take some work.","category":"page"},{"location":"#Overview","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"Overview","text":"","category":"section"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"The exercises are described as follows:","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"Exercise 1 is solving a simple stiff ordinary differential equation. This is an introductory exercise to get users acquainted with the syntax.\nExercise 2 takes the user through solving a stiff ordinary differential equation and using the ModelingToolkit.jl to automatically convert the function to a symbolic form to derive the analytical Jacobian to speed up the solver. The same biological system is then solved with stochasticity, utilizing EnsembleProblems to understand 95% bounds on the solution. Finally, probabilistic programming is employed to perform Bayesian parameter estimation of the parameters against data.\nExercise 3 takes the user through defining hybrid delay differential equation, that is a differential equation with events, and using differentiable programming techniques (automatic differentiation) to to perform gradient-based parameter estimation.\nExercise 4 takes the user through differential-algebraic equation (DAE) modeling, the concept of index, and using both mass-matrix and implicit ODE representations. This will require doing a bit of math, but the student will understand how to change their equations to make their DAE numerically easier for the integrators.\nExercise 5 has one build an acausal model, a DAE system through a component-based modeling approach. Using a tutorial model of an RC circuit (resistor and capacitor) plus some information about inductors, the user then builds new ModelingToolkit components for an inductor and generates an RLC circuit to be simulated.\nExercise 6 takes the user through optimizing a PDE solver, utilizing automatic sparsity pattern recognition, automatic conversion of numerical codes to symbolic codes for analytical construction of the Jacobian, preconditioned GMRES, and setting up a solver for IMEX and GPUs, and compute adjoints of PDEs.\nExercise 7 focuses on a chaotic orbit, utilizing parallel ensembles across supercomputers and GPUs to quickly describe phase space.\nExercise 8 takes the user through training a neural stochastic differential equation, using GPU-accleration and adjoints through Flux.jl's neural network framework to build efficient training codes.\nExercise 9 is a deep dive into controls analysis on nonlinear models. The user starts by building an acausal model of a DC motor, which is augmented with a PI-controller that is tuned to control the actions of the motor.","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"This exercise worksheet is meant to be a living document leading new users through a deep dive of the SciML feature set. If you further suggestions or want to contribute new problems, please  open an issue or PR at the SciMLWorkshop.jl repository.","category":"page"},{"location":"#Reproducibility","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"</details>","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"</details>","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"using Pkg # hide\nPkg.status(;mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"</details>","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"You can also download the\n<a href=\"","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\"","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"\">manifest</a> file and the\n<a href=\"","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"using TOML\nversion = TOML.parse(read(\"../../Project.toml\",String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\",String))[\"name\"]\nlink = \"https://github.com/SciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\"","category":"page"},{"location":"","page":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","title":"SciMLWorkshop: Workshop Materials for Training in Scientific Computing and Scientific Machine Learning (SciML)","text":"\">project</a> file.","category":"page"},{"location":"solutions/mtk_chemical_reaction/#ModelingToolkit-Simple-Chemical-Reaction-ODE-(B)","page":"ModelingToolkit Simple Chemical Reaction ODE (B)","title":"ModelingToolkit Simple Chemical Reaction ODE (B)","text":"","category":"section"},{"location":"solutions/mtk_chemical_reaction/","page":"ModelingToolkit Simple Chemical Reaction ODE (B)","title":"ModelingToolkit Simple Chemical Reaction ODE (B)","text":"using ModelingToolkit, DifferentialEquations, Plots\n@variables t\n@variables begin\n    y1(t) = 1.0\n    y2(t) = 0.0\n    y3(t) = 0.0\n    y4(t) = 0.0\n    y5(t) = 0.0\n    y6(t) = 0.0\n    y7(t) = 0.0\n    y8(t) = 0.0057\nend\n@parameters begin\n    k1 = 1.71\n    k2 = 280.0\n    k3 = 8.32\n    k4 = 0.69\n    k5 = 0.43\n    k6 = 1.81\nend\nD = Differential(t)\neqs = [\n    D(y1) ~ (-k1*y1 + k5*y2 + k3*y3 + 0.0007),\n    D(y2) ~ (k1*y1 - 8.75*y2),\n    D(y3) ~ (-10.03*y3 + k5*y4 + 0.035*y5),\n    D(y4) ~ (k3*y2 + k1*y3 - 1.12*y4),\n    D(y5) ~ (-1.745*y5 + k5*y6 + k5*y7),\n    D(y6) ~ (-k2*y6*y8 + k4*y4 + k1*y5 - k5*y6 + k4*y7),\n    D(y7) ~ (k2*y6*y8 - k6*y7),\n    D(y8) ~ (-k2*y6*y8 + k6*y7)\n]\n@named hires_model = ODESystem(eqs)\n\nprob = ODEProblem(hires_model, [], (0.0, 321.8122))\nsol = solve(prob)\npp = plot(sol, dpi=400)","category":"page"}]
}
